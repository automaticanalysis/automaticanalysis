function [td, sts, mfpfile] = mw_mfp(rps, do_td, do_mm, do_mfp, keep, shifted, squared, cleanup, fout);
%
% [td, sts] = mw_mfp(rps, do_td, do_mm, do_mfp, keep, shifted, squared, cleanup, fout);
%
% Function to calculate several indicators of individual motion in
% fMRI timeseries. There are several input options (short version):
%
%	rps       - realignment parameters or directory or empty (will prompt)
%	do_td     - calculate total displacement: 0 or 1 (default) or -1
%	do_mm     - calculate motion mask: 0 or 1 (default)
%	do_mfp    - calculate motion fingerprint: 0 or 1 (default)
%	keep      - keep n timecourses of the mfp: 1-9, default: 3
%	shifted   - include shifted timecourses in mfp: 0 or 1 (default)
%	squared   - include squared timecourses in mfp: 0 (default) or 1
%	cleanup   - delete temporary files: 0 or 1 (default); 2 also hides graphics
%	fout      - name of additional outfile: empty or additional directory
%
% Long version:
% rps: the realignment parameters as generated by spm. Can also be
% the name of a directory which will then be searched (with !all
% subdirectories!) for those parameters. Required: if not provided,
% will prompt for it.
%
% do_td: combines translations and rotations into one comprehensive 
% indicator of total displacement, using an indicator of average
% cortical distance (davg). This is shown as a figure and saved
% in each session's directory. Defaults to 1, but can be set to 0.
% NB: In contrast to earlier versions, a standard (fixed) davg as set
% in the options will be used by default; for using the individually-
% determined value (legacy behavior :) set do_td to -1;
%
% do_mm: generate a motion mask, illustrating the maximal amount
% of total displacement each voxel experienced as a function of
% rotation and translation during a given run; this is saved as an 
% image volume ('..._motmask.img') in each session's directory.
% Defaults to 1, but can be set to 0.
%
% do_mfp: a motion fingerprint which is meant to reflect the 
% signal changes occurring in the brain as a function of 
% motion in this individual subject. This generates a temporary sub-
% folder and saves the results in a text file in each session's
% directory (see below). Defaults to 1, but can be set to 0.
%
% keep: include how many mfp timecourses in resulting txt-file?
% While 9 mfp's will always be determined, not necessarily all
% may be used later-on. Defaults to 3 but can be set to [1-9].
%
% shifted: when generating a motion fingerprint, this is 
% "Volterra option 1", meaning that the shifted (-1 timpoint)
% mfp timecourses are included in the resulting text file.
% Defaults to 1 but can be set to 0.
%
% squared: when generating a motion fingerprint, this is 
% "Volterra option 2", meaning that the squared mfp timecourses
% are included in the resulting text file. Defaults to 0
% but can be set to 1.
%
% cleanup: this indicates whether you want to remove the 
% subdirectory created when generating a motion fingerprint.
% Defaults to 1 but can be set to 0. Setting it to 2 will also 
% hide the figure and suppress command line output (silent mode),
% which may be useful when scripting larger collections.
%
% fout: name of additional output file or folder. If specified (full path),
% a graphics summary will additionally be saved there. A 'mw_motion.png'
% in the same directory as the realignment parameters will always be saved.
%
% The workspace output is two nsess x 1 cells, containing vectors of total
% displacement (td) and scan-to-scan total displacement (sts), which
% can be used to assess motion, for example doing something like
% for i=1:size(td,1), figure; plot(td{i,1}); hold on; bar(sts{i,1}); end;
% If do_td is set to 0, this will return 'ND' in both cells. Further, the 
% full name of the mfp output file (if generated) will be returned (else this
% variable will be empty). Note that all results will always be saved in a
% mw_motion.mat file in the same directory as the realignment parameters
% (which can independently be assessed using mw_anamot.m).
%
% For straightforward inclusion in statistical models, the motion fingerprint
% (if generated) is stored in a mw_mfp_kX_shY_sqZ.txt file, with
% X denoting the number of kept timecourses, Y denoting wether shifted
% versions were included, and Z denoting whether squared versions were
% included. Defaults (3,1,0) can be changed by passing inputs, see above.
%
% In usual mode, only the most pertinent results are saved as variables
% in a mw_motion.mat file; in debug mode, all (!) results are saved; 
% for details re: the variables included, see further below
% in this script (search for save :). 
% For further information, please refer to and cite 
%
%   Wilke M: An alternative approach towards assessing and
%   accounting for individual motion in fMRI timeseries;
%   NeuroImage 2012, 59: 2062-2072
% 
% available at http://dx.doi.org/10.1016/j.neuroimage.2011.10.043
%
% as well as
%
%   Wilke M: Isolated assessment of translation or rotation
%   severely underestimates the effects of subject motion
%   in fMRI data;
%   PLoS ONE 2014, 9: e106498
% 
% freely available at http://www.dx.doi.org/10.1371/journal.pone.0106498
%
% It requires the following functions to run properly:
%
%   mw_brainmask (included, mainly courtesy of John Ashburner)
%   findn (included, courtesy of the Mathworks File Exchange)
%   subdir (included, courtesy of the Mathworks File Exchange)
%   
% The following functions are "nice-to-have" but alternatives
% are built in:
%
%   expfit (from Matlab's statistics toolbox) 
%
% Idea and implementation by Marko Wilke, see the accompanying history
% file for version information.
%
% This program is free software: you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
% or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
% for more details. You should have received a copy of the GNU General
% Public License along with this program. If not, see <http://www.gnu.org/licenses/>.
%


% ==========================================================================================================
%                                          Preludes: settings, inputs, etc.
% ==========================================================================================================


% File version: 1.5.1, 2014-11-13


% get, check spm version
  ver = spm('ver');
  if str2double(ver(regexp(ver,'[0-9]'))) < 8

	fprintf(['  This does not seem to be spm in a version >= 8, as required for this script - aborting...'  '\n']);
	return;

  end;


% settings
  r = 10;                 % diameter (in voxels) of region of interest
  davg_s = 65;            % standard (fixed) value for davg (in mm), may be overruled by do_mfp (see above)
  myhold = [7 7 7 0 0 0]; % set interpolation
  perc = 25;              % if expfit is not found, use perc % of input voxels
  do_fancy = 1;           % show additional fancy plots of motion trajectory :)
  mysteps = 40;           % use how many colors in the colormap
  multivol = 0;           % will usually work with 3D images
  debug_mode = 0;         % will usually not need to save every single bit of generated data
  runthrough = 1;         % this makes mw_mfp report, but not fail, on errors during mask creation
  showmask = 1;           % do or do not show result of mask creation
  pres = 300;             % resolution of graphical output
  mydir = 'mfp';          % name of mfp-subdirectory
  vs_def = 3;             % default voxel size to assume if data is not found
  mfpfile = [];           % initialize file output name


% further settings
  warning off MATLAB:MKDIR:DirectoryExists
  oris_id = char('RPI', 'RPS', 'RAS', 'LAS', 'LPS', 'LAI', 'RAI', 'LPI', 'CTR');         % note that this refers to voxel space
  steps = [-1 -1 -1; -1 -1 1; -1 1 1; 1 1 1; 1 -1 1; 1 1 -1; -1 1 -1; 1 -1 -1; 0 0 0];   % note that these may be adapted (see below)


% options for spm functions
  opts_reslice = struct('mask',0,'which',2,'mean',1,'interp',7);


% check inputs
  if nargin == 0


	rps = spm_select([1 Inf],'any','Select realignment parameter file(s)',[],pwd,'^rp.*txt$');
	if isempty(rps),  return;  end;

  elseif isdir(rps)


	% if a directory was given, search all subdirectories; watch out for trailing filesep
	  if rps(1,end) == filesep,  rps = rps(1,1:end-1);  end;
	  myparams = subdir([rps filesep 'rp_*.txt']);
	  if isempty(myparams)

		% inform user
		  disp(['... sorry, no realignment parameters were found in  ' rps ', please check manually...']);
		  return;
	  else

		  rps = char(myparams(:).name);
	  end;

  end;
  if nargin < 2 || isempty(do_td),    do_td = 1;   end;
  if nargin < 3 || isempty(do_mm),    do_mm = 1;   end;
  if nargin < 4 || isempty(do_mfp),   do_mfp = 1;  end;
  if nargin < 5 || isempty(keep),     keep = 3;    end;
  if nargin < 6 || isempty(shifted),  shifted = 1; end;
  if nargin < 7 || isempty(squared),  squared = 0; end;
  if nargin < 8 || isempty(cleanup),  cleanup = 1; end;
  if nargin < 9,                      fout = [];   end;


% use standard (default) or individual davg (legacy behavior, only upon request)?
  davg_i = 0;
  if do_td < 0,  do_td = 1;  davg_i = 1;  end;


% get a nice and clean environment (or not?
  if cleanup ~= 2

	  clc
	  silent = 0;
	  fg = spm_figure('Findwin','Graphics');
	  fi = spm_figure('Findwin','Interactive');
	  spm_figure('Clear',fg);
	  spm_figure('Clear',fi);
	  disp(['=== Welcome to ' mfilename ' ===']);
	  disp(' ');

  else

	  silent = 1;

  end;


% ==========================================================================================================
%                                     Get going: loop over input data
% ==========================================================================================================


% storage
  td_a  = cell(size(rps,1),1);
  sts_a = cell(size(rps,1),1);


  tic;
  for i = 1:size(rps,1)


	% inform user
	  if silent == 0,  disp(['... processing session ' num2str(i) ' of ' num2str(size(rps,1)) ', please wait...']);  end;


	% get, load current parameters; consider special case of assessing pwd
	  [p, nm] = spm_fileparts(rps(i,:));
	  if isempty(p),  p = pwd;  end;
	  pr = load(deblank(rps(i,:)));


	% check if we have a mask, else, create one if necessary
	  if  do_td ~= 0  && (do_mm == 1 || do_mfp == 1  || davg_i == 1)


		  mask = spm_select('List', p, ['^' nm(4:end) '.(img|nii)']);
		  [junk, junk, e] = spm_fileparts(mask);
		  if isempty(mask)

			np = strrep(p, filesep, '/');
			error(['No matching image found for ' nm e ' in ' np ', aborting!']);

		  elseif ~isempty(spm_select('List', p, ['^' nm(4:end) '_mask.(img|nii)']))

			mask = [p filesep spm_select('List', p, ['^' nm(4:end) '_mask.(img|nii)'])];

		  else
			try

				mask = mw_brainmask([p filesep mask]);

			catch
				try

					% catch 1: try dirty fix for int16-images with a lot of background
					  V = spm_vol([p filesep mask]);  if size(V,1) > 1,  V = V(1);  end;
					  spm_smooth(V,[p filesep nm(4:end) '_mask' e],[0 0 0],2);
					  mask = mw_brainmask([p filesep nm(4:end) '_mask' e],1,1);

				catch

					try

						% catch 2: try desparate but simple approach of largest-cluster-with-above-average-intensity...
						  V = spm_vol([p filesep mask]);
						  vol = mean(spm_read_vols(V),4);
						  vol = vol > mean(vol(:));
						  [clus_vol,num] = spm_bwlabel(double(vol),18);
						  cs = 0;
						  targ = 0;
						  for k = 1:num

							cs_temp = sum(sum(sum(clus_vol == k)));
							if cs_temp > cs,  cs = cs_temp; targ = k; end;

						  end;
						  vol = vol .* (clus_vol == targ);
						  V = V(1);
						  [p, nm, e] = spm_fileparts(V.fname);
						  V.fname = [p filesep nm '_mask' e];
						  V.pinfo = [1 0]';
						  V.dt = [spm_type('uint8') spm_platform('bigend')];
						  spm_write_vol(V, double(vol));
						  disp('   ... using backup strategy to create brain mask, please check results manually...');
						  mask = V.fname;
						  showmask = 1;

					catch

						% obviously that didn't work either: my give up :(
						  np = strrep(p, filesep, '/');
						  if runthrough == 1


							  disp('    An error occurred when creating the brainmask');
							  disp(['    with file ' num2str(i) '/' num2str(size(rps,1)) ' from ' np ', bailing out...']);
							  return;

						  else

							  error(['An error occurred when creating the brainmask from ' np ', aborting!']);
						  end;
					end;
				end;
			end;
		  end;


		% get handle & average voxel size
		  try

			V = spm_vol(mask);
		  catch

			try

				% very weirdly, this sometimes fails...
				  V = spm_vol([p filesep mask]);

			catch
				  np = strrep(p, filesep, '/');
				  if runthrough == 1


					  disp('    An error occurred when creating the brainmask');
					  disp(['    with file ' num2str(i) '/' num2str(size(rps,1)) ' from ' np ', bailing out...']);
					  return;
				  else

					  error(['An error occurred when creating the brainmask from ' np ', aborting!']);
				  end;
			  end;
		  end;
		  vs = mean(sqrt(sum(V.mat(1:3,1:3).^2)));


		% potentially show results
		  if showmask == 1  && cleanup ~= 2

			showme = char([mask ',1'], [p filesep spm_select('List', [p], ['^' nm(4:end) '.(img|nii)']) ',1']);
			evalc('spm_check_registration(showme);');

		  end;

	  else

		% looks like we shall only look at TD at standard cortical distance
		  vs = vs_def;
		  mask = [];

	  end;


	% ==========================================================================================================
	%                        option 1: compute and show total displacement at d_avg?
	% ==========================================================================================================
	  if do_td == 1


		% get individual davg (always)
		  if ~isempty(mask)

			  evalc('surf = spm_surf(mask,2)');
			  surf = surf.surffile{1,1};
			  FV = gifti(surf);
			  center = (FV.vertices(FV.faces(:,:),:));
			  center = reshape(center, [size(FV.faces,1) 3 3]);
			  center = squeeze(mean(center,2));
			  ori_dist = sqrt(sum((center.*-1).^2,2))';
			  davg = mean(ori_dist);
			  davg_ind = davg;

		  else

			  davg_ind = NaN;

		  end;


		% use individual davg (not always)?
		  if davg_i == 0

			  davg = davg_s;
			  if silent == 0,  disp(['   ... assessing total displacement at d_avg (using standard value of ' sprintf('%02.1f', davg) ' mm), please wait...']);  end;

		  else

			  if silent == 0,  disp(['   ... assessing total displacement at d_avg (using individual value of ' sprintf('%02.1f', davg) ' mm), please wait...']);  end;

		  end;


		% total displacement at davg
		  td = zeros(1,size(pr,1));
		  for ii = 2:size(pr,1)

			  dx = pr(ii,1) + (pr(ii,4) .* davg);
			  dy = pr(ii,2) + (pr(ii,5) .* davg);
			  dz = pr(ii,3) + (pr(ii,6) .* davg);
			  td(1,ii) = sqrt(dx.^2 + dy.^2 + dz.^2);
		  end;


		% scan-to-scan discplacement at davg
		  sts = zeros(1,size(pr,1));
		  for ii = 2:size(pr,1)

			  dx = (pr(ii,1)-pr(ii-1,1)) + (pr(ii,4) .* davg -pr(ii-1,4) .* davg);
			  dy = (pr(ii,2)-pr(ii-1,2)) + (pr(ii,5) .* davg -pr(ii-1,5) .* davg);
			  dz = (pr(ii,3)-pr(ii-1,3)) + (pr(ii,6) .* davg -pr(ii-1,6) .* davg);
			  sts(1,ii) = sqrt(dx.^2 + dy.^2 + dz.^2);
		  end;


		% create graphics
		  gcf1 = figure;
		  set(0,'Units','pixels');
		  if cleanup == 2,  set(gcf1, 'Visible', 'off');  end;
		  scnsize = get(0,'ScreenSize');
		  if do_mfp == 0,   nrows = 3;  else,  nrows = 4;  end;
		  if do_fancy == 1, nrows = nrows + 1;             end;


		% try to steal position from spm graphics window, move to left
		  try

			  pos1 = get(spm_figure('Findwin','Graphics'), 'Position');
			  pos1(1) = pos1(1)/10;

		  catch

			% fallback position...
			  pos1 = [round(scnsize(3)/40), round(scnsize(4)/40), round(scnsize(3)/10*6), round(scnsize(4)*nrows/5.75)];

		  end;
		  set(gcf1, 'Position', pos1, 'Color', 'w', 'Renderer', 'zbuffer');
		  set(gcf1, 'Name', ['Motion parameters from ' p]);


		% optimize scaling
		  mot = abs(pr(:,1:3));
		  deg = abs((pr(:,4:6)*180/pi));
		  scaleme = ([mot deg td' sts']);
		  scaleme = [ceil(max(abs(scaleme(:)))) * -1 ceil(max(abs(scaleme(:))))];


		% first, the usual, well-known suspects: translations...
		  subplot(nrows,3,[1 2 3],'replace');
		  plot(pr(:,1:3));
		  grid on;
		  xlim([0 size(pr,1)]);
		  ylim(scaleme);
		  title('Realignment parameters: shifts [top, in mm] and rotations [middle, in dg]');


		% ... and rotations...
		  subplot(nrows,3,[4 5 6],'replace');
		  plot(pr(:,4:6)*180/pi);
		  grid on;
		  xlim([0 size(pr,1)]);
		  ylim(scaleme);
		  title(['(data from ' p ')'], 'interpreter', 'none');


		% ... and now, total displacement at d_avg: total & scan-to-scan
		  sp3 = subplot(nrows,3,[7 8 9],'replace');
		  plot(td);
		  hold on;
		  bar(sts);
		  grid on;
		  xlim([0 size(pr,1)]);
		  ylim([0 max(scaleme)]);


		% use title to remind user of choice
		  if davg == davg_s

			  title(['Total (line) and scan-to-scan (bars) displacement at d_a_v_g (standard: ' sprintf('%02.1f', davg) ' mm)']);

		  else

			  title(['Total (line) and scan-to-scan (bars) displacement at d_a_v_g (individual: ' sprintf('%02.1f', davg) ' mm)']);

		  end;


		% use the old rule of thumb to show "one voxel size"
		  if max(scaleme) > vs

			  props=get(sp3);
			  lh1 = line(props.XLim,[-vs -vs],'color','r', 'linestyle', '--');
			  lh2 = line(props.XLim,[vs   vs],'color','r', 'linestyle', '--');
			  drawnow;
		  end;


		% annotate
		  [xm] = find(mot == max(mot(:)));
		  [xd] = find(deg == max(deg(:)));
		  [junk, xt] = find(td == max(td(:)));
		  [junk, xs] = find(sts == max(sts(:)));
		  axes('Position',[0.005,0.005,0.1,0.1],'Visible','off');
		  text(1,0.1,['MaxVal@scan: T:' sprintf('%01.1f', max(mot(:))) ' mm @ scan ' num2str(xm(1)) '; R: ' sprintf('%01.1f', max(deg(:))) ' ï¿½ @ scan ' num2str(xd(1)) '; TD: '  sprintf('%01.1f', max(td(:))) ' mm @ scan ' num2str(xt) '; STS: '  sprintf('%01.1f', max(sts(:))) ' mm @ scan ' num2str(xs) '.'],'FontSize',8,'interpreter','none');


		% save (always, irrespective of debug_mode)
		% - td contains total displacement at davg
		% - sts contains scan-to-scan-displacement at davg
		% - pr contains the underlying motion parameters
		% - davg is the average cortical distance used in calculations (standard or indivdual)
		% - davg_ind is the individual average cortical distance (used or not)
		% - davg_i indicates whether davg_ind was actually used (1) or not (0)
		  save([p filesep 'mw_motion.mat'], 'td', 'sts', 'pr', 'davg', 'davg_ind', 'davg_i');


		% store
		  td_a{i,1}  = td;
		  sts_a{i,1} = sts;
 
	  else

		% inform user in case an output is requested but td not done
		  td_a{i,1}  = 'ND';
		  sts_a{i,1} = 'ND';
	  end;


	% ==========================================================================================================
	%                        option 2: generate a motion mask?
	% ==========================================================================================================
	  if do_mm == 1


		% inform user
		  if silent == 0,  disp('   ... generating motion mask, please wait...');  end;


		% load mask
		  m = spm_read_vols(spm_vol(mask));


		% get going: find voxel indices to all voxels > 0.5
		  [x,y,z] = ind2sub(size(m), find(m > 0.5));


		% convert voxel to mm
		  tmp = [x y z ones(size(x,1),1)];
		  tmp = (V.mat*tmp')';
 		  tmp(:,4) = [];


		% calculate distance from 0,0,0 (= origin) for each voxel
		  ori_dist = sqrt(sum((tmp.*-1).^2,2));


		% store back, such that the voxel value becomes its distance
		  dist = zeros(size(m));
		  for ii = 1:size(x,1)

			dist(x(ii),y(ii),z(ii)) = ori_dist(ii);
		  end;


		% calculate length of vector that was induced by motion
		% according to l = sqrt(sum of squared shifts)
		  store_td = repmat(m,[1,1,1,size(pr,1)]);
		  for ii = 2:size(pr,1)


			% calculate vector length resulting from translation; global, thus easy
			%  trans = sqrt(pr(ii,1)^2 + pr(ii,2)^2 + pr(ii,3)^2);
			%  trans = trans .* m;


			% rotation; not global, thus (a bit) harder
			%  pitch = (pr(ii,4) .* dist) .* (pr(ii,4) .* dist);
			%  roll  = (pr(ii,5) .* dist) .* (pr(ii,5) .* dist);
			%  yaw   = (pr(ii,6) .* dist) .* (pr(ii,6) .* dist);
			%  rot   = sqrt(pitch + roll + yaw);


			% find and store combined displacement
			  dx = (pr(ii,1) .*m) + (pr(ii,4) .* dist);
			  dy = (pr(ii,2) .*m) + (pr(ii,5) .* dist);
			  dz = (pr(ii,3) .*m) + (pr(ii,6) .* dist);
			  store_td(:,:,:,ii) = sqrt(dx.^2 + dy.^2 + dz.^2);

		  end;


		% now generate motmask, find, save datapoint with maximum total displacement
		  [junk,maxp] = max(squeeze(sum(sum(sum(store_td)))));
		  V.fname = [p filesep 'mw_motmask.img'];
		  V.dt = [16 0];
		  V.descrip = ['Max total displacement (mm at scan #' num2str(maxp) '); data from ' p];
		  spm_write_vol(V,store_td(:,:,:,maxp));
		  if showmask == 0 && cleanup ~= 2,  spm_check_registration(str2mat(V.fname));  end;


		% save results (only in debug mode)
		% - store_td contains total displacement per voxel per timepoint
		  if debug_mode == 1

			  try
				  save([p filesep 'mw_motion.mat'], 'store_td', '-append');
			  catch
				  save([p filesep 'mw_motion.mat'], 'store_td');
			  end;
		  end;
	  end;


	% ==========================================================================================================
	%                        option 3: generate a motion fingerprint?
	% ==========================================================================================================
	  if do_mfp == 1


		% inform user
		  if silent == 0,  disp('   ... generating motion fingerprint, please wait...');  end;


		% load mask
		  m = spm_read_vols(spm_vol(mask));
		  dims_m = size(m);


		% sanity check and backup strategy for very "asymmetrical" datasets (i.e., few slices)
		% as progressing equally towards center (below) does not work in these cases
		  if min(dims_m) / max(dims_m) < 0.6  % changed from 0.5


			% modify steps
			  % modi = (dims_m == max(dims_m)) + 1;
			  modi = (dims_m == max(dims_m)) .* floor(max(dims_m)/min(dims_m));
			  modi(modi == 0) = 1;
			  steps = steps .* repmat(modi,[size(steps,1) 1]);
			  disp(['   ... found few slices (' num2str(min(dims_m)) ') with much higher in-plane resolution (' num2str(max(dims_m)) '), adapting steps...']);
		  end;

          % [TA] set ROI diameter accordingly
          r = floor(min(dims_m)/2);
          
		% prepare storage, folder, files
		  mfps = zeros(size(steps,1),size(pr,1));
		  img = [p filesep spm_select('List', p, ['^' nm(4:end) '.(img|nii)'])];
		  [junk, junk, e] = spm_fileparts(img);
		  try

			mkdir([p filesep mydir]);
		  catch
		  	np = strrep([p filesep mydir], filesep, '/');
			error(['Sorry, creation of directory ' np ' failed - please check permissions!']);
		  end;


		% get information on reference file, check if 4D
		  M = spm_get_space(img);
		  V = spm_vol(img);
		  if size(V,1) > 1,  V = V(1);  multivol = 1;  end;
		  c = spm_bsplinc(V,myhold);


		% get information on other files
		  if multivol == 0

			  imgs = spm_select('List', p, ['^' nm(4:8) '.*[0-9]' e]);
			  if size(imgs,1) ~= size(pr,1)

				np = strrep(p, filesep, '/');
				error(['Sorry, automated selection of files from ' np ' failed - please check naming convention:', ...
				' this script expects the files to begin with ' nm(4:8) ' and to end with a number!']);
			  else

				imgs = [repmat(p,size(imgs,1),1) repmat(filesep,size(imgs,1),1) imgs];
			  end;
		  else

			  imgs = img;
		  end;


		% ok, now estimate and potentially save motion*B0 interactions (this part created with generous help from Chloe Hutton!)
		  evalc('ds = spm_uw_estimate(imgs);');
		  fg = spm_figure('Findwin','Graphics');
		  spm_figure('Clear',fg);

		  if debug_mode == 1

			save([p filesep mydir filesep 'uw.mat'],'ds');
		  end;


		% initiate sampling grid; 
		  [x,y,z] = ndgrid(1:ds(1).P(1).dim(1),1:ds(1).P(1).dim(2),1:ds(1).P(1).dim(3));
		  xyz = [x(:) y(:) z(:) ones(prod(ds(1).P(1).dim(1:3)),1)];
		  clear x y z;
		  def_array = zeros(prod(ds(1).P(1).dim(1:3)),size(ds(1).beta,2));
		  Bx = spm_dctmtx(ds(1).P(1).dim(1),ds(1).order(1));
		  By = spm_dctmtx(ds(1).P(1).dim(2),ds(1).order(2));
		  Bz = spm_dctmtx(ds(1).P(1).dim(3),ds(1).order(3));
		  for ii=1:size(ds(1).beta,2)
			def_array(:,ii) = spm_get_def(Bx,By,Bz,ds(1).beta(:,ii));
		  end;


		% loop over images, apply deformation and move images out of alignment
		  imgs = 'junk';
		  for ii = 1:size(pr,1)


			% reuse original sampling
			  txyz = xyz;		


			% then, get deformation from current image
		          def = spm_get_image_def(ds(1).P(ii),ds(1),def_array);
		 	  txyz(:,2) = txyz(:,2) - def;  % subtract now from original instead of adding


			% apply to first image
			  ima = spm_bsplins(c,txyz(:,1),txyz(:,2),txyz(:,3),myhold);
			  ivol = reshape(ima,V.dim(1:3));


			% store away, re-using the parameters from the realignment parameters
			  PO = V;
			  PO.fname   = [p filesep mydir filesep 'image_' sprintf('%03.0f', ii) '.img'];
			  temp = pr(ii,:);
			  MM = inv(spm_matrix(temp));
			  PO.mat = MM*M;
			  spm_write_vol(PO,ivol);
			  imgs = char(imgs, [p filesep mydir filesep 'image_' sprintf('%03.0f', ii) '.img']);

		  end;
                  imgs(1,:) = [];


		% reslice, read in synthetic timeseries
		  evalc('spm_reslice(imgs,opts_reslice);');
		  rimgs = spm_select('List', [p filesep mydir], '^r.*\.img$');
		  cd([p filesep mydir]);
		  vols = spm_read_vols(spm_vol(rimgs));


		% set initial origins of the 9 mfp-ROI's, i.e., in the corners and the center
		  oris = zeros(9,3);
		  myoris = zeros(9,3);
		  oris(1,:) = [1,1,1];                          % RPI
		  oris(2,:) = [1,1,dims_m(3)];                  % RPS
		  oris(3,:) = [1,dims_m(2),dims_m(3)];          % RAS
		  oris(4,:) = [dims_m(1),dims_m(2),dims_m(3)];  % LAS
		  oris(5,:) = [dims_m(1),1,dims_m(3)];          % LPS
		  oris(6,:) = [dims_m(1),dims_m(2),1];          % LAI
		  oris(7,:) = [1,dims_m(2),1];                  % RAI
		  oris(8,:) = [dims_m(1),1,1];                  % LPI
		  oris(9,:) = round(mean(findn(m > 0.1)));      % CTR


		% now loop over ROI's
		  for ii = 1:size(oris,1)


			% get initial origin, move in until we encounter brain, store away
			  coord = oris(ii,:);
			  try

				  while round(m(coord(1),coord(2),coord(3))) == 0

					coord = coord - steps(ii,:);

				  end;
				  myoris(ii,:) = coord;

			  catch

				error('   Sory, an error occurred in mw_mfp while trying to determine the ROIs; this is usually caused by very asymmetrical or corrupt data; please check your images!');

			  end;


			% sanity check: avoid out-of-volume ROI
			  myoris(myoris <= floor(r/2)) = floor(r/2)+1;


			% get variance of timecourses from this ROI
			  targ = var(vols(coord(1)-floor(r/2):coord(1)+ceil(r/2), coord(2)-floor(r/2):coord(2)+ceil(r/2), coord(3)-floor(r/2):coord(3)+ceil(r/2),:),[],4);
			  targ(targ==0) = [];
			  targ = reshape(targ,1,[]);


			% identify voxels to keep
			  try

				% cleaner solution (but: requires statistics toolbox)...
				  [muhat] = expfit(sort(targ));

			  catch

				% ... if not possible, use upper "perc" percent of values (derived empirically)
				  disp(['   ... expfit not found, reverting to using ' num2str(perc) '% of input values!']);
				  j = sort(targ);
				  cut = round(length(j)/100*(100-perc));
				  muhat = j(cut+1);
			  end;


			% now get respective timecourses
			  targ = vols .* repmat(var(vols,[],4) > muhat, [1 1 1 size(vols,4)]);
                          coord = targ(coord(1)-floor(r/2):coord(1)+ceil(r/2), coord(2)-floor(r/2):coord(2)+ceil(r/2), coord(3)-floor(r/2):coord(3)+ceil(r/2),:);
			  coord = reshape(coord,[size(coord,1)*size(coord,2)*size(coord,3) size(coord,4)]);


			% relate signal changes to first
			  for iii = 1:size(coord,1)

				coord(iii,:) = (coord(iii,:) ./ coord(iii,1)) .* 100;
			  end;


			% prettify timecourses
			  coord(:,1) = 100;
			  coord(~isfinite(coord)) = NaN;
			  coord(var(coord,[],2)==0,:) = [];
			  coord(isnan(var(coord,[],2)),:) = [];
			  % disp(['   ... ROI ' num2str(ii) ', results are based on ' num2str(size(coord,1)) ' voxels.']);


			% and store away
			  mfps(ii,:) = mean(coord) - mean(mean(coord));
		  end;


		% now find correlation between mfp's (based on spm's approach to orthogonality)
		  myorth = zeros(size(mfps,1), size(mfps,1));
		  for ii = 1:size(mfps,1)

			% get first mfp
			  a = mfps(ii,:)';

			  for iii = 1:size(mfps,1)

				% get other mfp
				  b = mfps(iii,:)';
				  myorth(ii,iii) = (a'*b./sqrt(sum(a.^2)*sum(b.^2)));
			  end;
		  end;


		% identify those with overall least correlation with others
		  temp = sortrows([sum(abs(myorth)); 1:size(myorth,1)]');
		  inds = temp(:,2);


		% retain "keep" mfp
		  inds  = inds(1:keep);
		  curr_tc = mfps(inds,:);


		% get origins of kept timecourses
		  temp = oris_id(inds,:);
		  show = temp(1,:); for j = 2:size(temp,1), show = [show '/' temp(j,:)]; end


		% potentially "Volterra-expand" (as per options set above)
		  if shifted == 1

			temp = [curr_tc(:,2:end) mean(curr_tc,2)];
			curr_tc = [curr_tc; temp];

		  end;
		  if squared == 1

			temp = curr_tc.^2;
			curr_tc = [curr_tc; temp];
		  end;


		% save resulting (chosen) mfp's into a text file, readily usable for later inclusion on the 1st level
		  curr_tc = curr_tc';
		  temp = [p filesep 'mw_mfp_k' num2str(keep) '_sh' num2str(shifted) '_sq' num2str(squared) '.txt'];
		  save(temp, 'curr_tc', '-ascii', '-double');


		% update output file name?
		  if isempty(mfpfile)


			% first/only session
			  mfpfile = temp;

		  else

			% not first or only session...
			  mfpfile = char(mfpfile, temp);

		  end;


		% update plot?
		  if do_td == 1


			% ... motion fingerprint...
			  set(0,'CurrentFigure',gcf1);
			  subplot(nrows,3,[10 11 12],'replace');
			  plot(curr_tc);
			  hold on;
			  grid on;
			  xlim([0 size(pr,1)]);
			  ylim([floor(min(curr_tc(:))) ceil(max(curr_tc(:)))]);
			  if shifted == 0, withshift  = 'no';  else,  withshift  = 'incl.';  end;
			  if squared == 0, withsquare = 'no';  else,  withsquare = 'incl.';  end;
			  title(['Motion fingerprint (from ' show '), ' withshift ' shifted, ' withsquare ' squared versions']);

		  end;


		% save results (always, irrespective of debug_mode)
		% - myoris contains the center voxel location of the mfp ROIs;
		% - oris_id contains the labels of the mfp ROIs;
		% - show identifies the retained mfp's;
		% - mfps contains all motion fingerprint
		% - inds contains the indices to the mfp's with least correlation with others
		% - myorth contains the corresponding correlation matrix
		  try
			  save([p filesep 'mw_motion.mat'], 'myoris', 'oris_id', 'show', 'mfps', 'inds', 'myorth', '-append');
		  catch
			  save([p filesep 'mw_motion.mat'], 'myoris', 'oris_id', 'show', 'mfps', 'inds', 'myorth');
		  end;


		% cleanup?
		  cd(p);
		  if cleanup > 0

			  try
				delete([p filesep mydir filesep '*']);
				rmdir([p filesep mydir]);
			  catch
			  	np = strrep([p filesep mydir], filesep, '/');
				error(['Sorry, deletion of directory ' np ' failed - please check permissions!']);
			  end;
		  end;

	  end;


	% add fancy plot?
	  if do_fancy == 1 && exist('davg') == 1


		% ... seems like we have a go...
		  set(0,'CurrentFigure',gcf1);


		% compute combined motion in all directions
		  temp = zeros(size(pr,1),3);
		  for ii = 1:size(pr,1);
			temp(ii,1) = pr(ii,1) + (pr(ii,4) .* davg);
			temp(ii,2) = pr(ii,2) + (pr(ii,5) .* davg);
			temp(ii,3) = pr(ii,3) + (pr(ii,6) .* davg);
		  end;
		  maxd = max(abs(temp(:)));
		  if maxd < vs,  mybound = vs;  else,  mybound = ceil(maxd);  end;


		% generate colormap, remove blue values (lower 50%)
		  cm = colormap(jet(mysteps+round(mysteps/2)));
		  cm(1:round(mysteps/2),:) = [];


		% scale results to colormap, set values above vs to red and avoid <1
		  thr = vs;
		  store = round(td.*mysteps/thr);
		  store(store >= mysteps) = mysteps;
		  store(store < 1) = 1;


		% ... and show
		  if nrows == 4

			subplot(nrows,3,10,'replace');

		  elseif nrows == 5

			subplot(nrows,3,13,'replace');
		  end;
		  gca1 = gca;
		  set(gca1,'XTick',[-round(vs) 0 round(vs)],'YTick',[-round(vs) 0 round(vs)],'DataAspectRatio',[1 1 1]);
		  xlim(gca1,[-round(mybound) round(mybound)]);
		  ylim(gca1,[-round(mybound) round(mybound)]);
		  box(gca1,'on');
		  grid(gca1,'on');
		  hold(gca1,'all');
		  for ii = 1:size(temp,1)

			  scatter(temp(ii,2),temp(ii,3),[],cm(store(ii),:),'filled');
			  line([0 temp(ii,2)],[0 temp(ii,3)], 'LineStyle',':','Color',[0.8 0.8 0.8]);
		  end;
 		  title('TD in Y & Z...');


		% ... and show
		  if nrows == 4

			subplot(nrows,3,11,'replace');

		  elseif nrows == 5

			subplot(nrows,3,14,'replace');
		  end;
		  gca1 = gca;
		  set(gca1,'XTick',[-round(vs) 0 round(vs)],'YTick',[-round(vs) 0 round(vs)],'DataAspectRatio',[1 1 1]);
		  xlim(gca1,[-round(mybound) round(mybound)]);
		  ylim(gca1,[-round(mybound) round(mybound)]);
		  box(gca1,'on');
		  grid(gca1,'on');
		  hold(gca1,'all');
		  for ii = 1:size(temp,1)

			  scatter(temp(ii,1),temp(ii,3),[],cm(store(ii),:),'filled');
			  line([0 temp(ii,1)],[0 temp(ii,3)], 'LineStyle',':','Color',[0.8 0.8 0.8]);
		  end;
 		  title('... X & Z ...');


		% ... and show
		  if nrows == 4

			subplot(nrows,3,12,'replace');

		  elseif nrows == 5

			subplot(nrows,3,15,'replace');
		  end;
		  gca1 = gca;
		  set(gca1,'XTick',[-round(vs) 0 round(vs)],'YTick',[-round(vs) 0 round(vs)],'DataAspectRatio',[1 1 1]);
		  xlim(gca1,[-round(mybound) round(mybound)]);
		  ylim(gca1,[-round(mybound) round(mybound)]);
		  box(gca1,'on');
		  grid(gca1,'on');
		  hold(gca1,'all');
		  for ii = 1:size(temp,1)

			  scatter(temp(ii,1),temp(ii,2),[],cm(store(ii),:),'filled');
			  line([0 temp(ii,1)],[0 temp(ii,2)], 'LineStyle',':','Color',[0.8 0.8 0.8]);
		  end;
 		  title('... and X & Y.');
	  end;


	% save (potentially updated) graphic into a png-file? Keep formatting as on screen
	  if do_td == 1

		  motname = [p filesep 'mw_motion.png'];
		  osu = get(gcf1,'Units'); opu = get(gcf1,'PaperUnits'); opp = get(gcf1,'PaperPosition');
		  set(gcf1,'Units','pixels'); scrpos = get(gcf1,'Position'); newpos = scrpos/100;
		  set(gcf1,'PaperUnits','inches','PaperPosition',newpos);
		  print(gcf1, '-dpng', '-noui', ['-r' num2str(pres)], motname);


		% save somewhere else, too?
		  if ~isempty(fout)

			  try

				% file or directory?
				  if isdir(fout)

					% fix for missing trailing filesep (problem of fileparts)
					  if fout(end) == filesep,  fout = fout(1:end-1);  end;
					  foutp = fout;
					  foutnm = [];
				  else

					  [foutp, foutnm] = spm_fileparts(fout);
				  end;


				% decide depending on number of output files
				  if ~isempty(foutnm) && size(rps,1) == 1

					  motname = [foutp filesep foutnm '.png'];
				  else

					  motname = [foutp filesep 'mw_motion_sess_' sprintf('%03.0f', i) '.png'];
				  end;
				  FNote = [' Results from ' p];
				  axes('Position',[0.01,0.01,0.1,0.1],'Visible','off','Tag','SPMprintFootnote')
				  text(0,0,FNote,'FontSize',8,'Interpreter','none','Rotation',90);
				  print(gcf1, '-dpng', '-noui', ['-r' num2str(pres)], motname);

			  catch

				  np = strrep(fout, filesep, '/');
				  if silent == 0,  disp(['   ... saving to additional outfile (in ' np ') failed, continuing...!']);  end;
			  end;
		  end;
		  set(gcf1,'Units',osu,'PaperUnits',opu,'PaperPosition',opp);
		  if nargin > 0 && size(rps,1) > 1 || cleanup == 2,  close(gcf1);  end
	  end;
  end;


% ==========================================================================================================
%                                          Cleanup time
% ==========================================================================================================


% time to say goodbye
  tt = toc;
  if silent == 0

	  disp(' ');
	  disp(['   ... results from this run, analyzing ' num2str(size(rps,1)) ' session(s), were stored in ']);
	  for i = 1:size(rps,1)

		  [p] = spm_fileparts(rps(i,:));
		  if isempty(p),  p = pwd;  end;
		  disp(['   ... ' p ' for session ' num2str(i) ';']);
	  end;
	  if ~isempty(fout) && size(rps,1) == 1

		disp(['   ... as well as in the additional outfile (' fout ');']);
	  end;
	  disp(['... thanks for using this script; this run took ' sprintf('%0.2f', tt/60) ' minutes.']); 
	  disp(' ');
	  disp('=== Thank you and have a nice day :) ===');
	  disp(' ');

  end;


% when all is said and done, rename output
  if nargout > 0
	td  = td_a;
	sts = sts_a;
  else
	td = 'Hope this helps :)';
  end;
  return;


% ==========================================================================================================
%                                          Embedded functions: #1, mw_brainmask
% ==========================================================================================================

function [mname, sname] = mw_brainmask(VF,mode,overwrite);
% Segment an MR image into Gray, White & CSF.
%
% Old spm function, based on John Ashburner's spm_segment.m 3756 2010-03-05 18:43:37,
% stripped off everything unnecessary and used here in order to generate a brainmask,
% mainly from native-space EPI-images. Inspired by the fieldmap which uses a similar approach.
%
% Adaptations by Marko Wilke, use at your own risk!

% set defaults
  flags.estimate.priors = char(...
        fullfile(spm('Dir'),'apriori','grey.nii'),...
        fullfile(spm('Dir'),'apriori','white.nii'),...
        fullfile(spm('Dir'),'apriori','csf.nii'));
  flags.estimate.reg    = 0.01;
  flags.estimate.cutoff = 30;
  flags.estimate.samp   = 3;
  flags.estimate.bb     =  [[-88 88]' [-122 86]' [-60 95]'];
  flags.estimate.affreg.smosrc = 8;
  flags.estimate.affreg.regtype = 'mni';
  flags.estimate.affreg.weight = '';
  flags.write.cleanup   = 1;
  flags.write.wrt_cor   = 0;
  flags.write.wrt_brV   = 1;
  flags.graphics        = 0;


% double check
  try

	junk = spm_vol(flags.estimate.priors(1,:));

  catch

	  flags.estimate.priors = char(...
	        fullfile(spm('Dir'),'toolbox','OldSeg','grey.nii'),...
	        fullfile(spm('Dir'),'toolbox','OldSeg','white.nii'),...
	        fullfile(spm('Dir'),'toolbox','OldSeg','csf.nii'));

	% be safe
	  try

		junk = spm_vol(flags.estimate.priors(1,:));

	  catch

		error(' Required OldSeg priors were not found for mw_brainmask in mw_mfp!');
	  end;
  end;


% process inputs
  if nargin == 0, VF = spm_select([Inf],'image',['Select image(s) to create brainmask from'],[],pwd,'.*');  end;
  if ischar(VF), VF= spm_vol(VF); if size(VF,1) > 1, VF = VF(1); end; end;
  if nargin < 2, mode = 1;       end;
  if nargin < 3, overwrite = 0;  end;


% inform user (all displays disabled below)?
  [mypath, myname, myext, v] = spm_fileparts(VF.fname);
  % disp(['  ... generating brainmask, please wait...']);


% continue
SP         = init_sp(flags.estimate,VF);
[x1,x2,x3] = get_sampling(SP.MM,VF,flags.estimate.samp,flags.estimate.bb);
BP         = init_bp(VF, flags.estimate.cutoff, flags.estimate.reg);
CP         = init_cp(VF,x3);
sums       = zeros(8,1);

for pp=1:length(x3),
    [raw,msk] = get_raw(VF,x1,x2,x3(pp));
    s         = get_sp(SP,x1,x2,x3(pp));
    CP        = update_cp_est(CP,s,raw,msk,pp);
    sums      = sums + reshape(sum(sum(s,1),2),8,1);
end;
sums = sums/sum(sums);
CP   = shake_cp(CP);

[CP,BP,SP] = run_segment(CP,BP,SP,VF,sums,x1,x2,x3);
[g,w,c] = get_gwc(VF,BP,SP,CP,sums,flags.write.wrt_cor);
if flags.write.cleanup, [g,w,c,b] = clean_gwc(g,w,c); end;

% Create the segmented images + the brain mask.
%-----------------------------------------------------------------------
[pth,nm,xt] = fileparts(deblank(VF(1).fname));

if flags.write.wrt_brV
    Nwrt = 4;
else
    Nwrt = 3;
end
for j=1:Nwrt,
    tmp   = fullfile(pth,['c', num2str(j), nm, xt]);
    if j==4, tmp = fullfile(pth,['BrMsk_', nm  xt]); end

    VO(j) = struct(...
        'fname',tmp,...
        'dim',    VF(1).dim(1:3),...
        'dt',     [spm_type('uint8'), spm_platform('bigend')],...
        'mat',    VF(1).mat,...
        'pinfo',  [1/255 0 0]',...
        'descrip','Brain mask, generated using old segment');
end;


VO(1).dat = g; VO(1).pinfo = VO(1).pinfo(1:2,:);
VO(2).dat = w; VO(2).pinfo = VO(2).pinfo(1:2,:);
VO(3).dat = c; VO(3).pinfo = VO(3).pinfo(1:2,:);
if flags.write.wrt_brV
    VO(4).dat = b; VO(4).pinfo = VO(4).pinfo(1:2,:);
end


% generate brainmask
  V = VO(4);
  if overwrite == 0,  V.fname = [mypath filesep myname '_mask' myext];  else,  V.fname = [mypath filesep myname myext];  end;
  V.descrip = 'Brain mask, generated using old segment';
  %  dat = double((g + w + c) > 0.5);
  dat = uint8(b > (max(b(:))/10));
  spm_write_vol(V,dat);


% outputs
  mname = V.fname;
  sname = [];


% generate surface?
  if mode == 2,  spm_surf(V.fname, 2);  [mypath, myname, j, j] = spm_fileparts(V.fname);  sname = [mypath filesep myname '.surf.gii'];  end;


% generate other classes?
  if mode == 3,

        V = VO(1);
        V.fname = [mypath filesep myname '_seg1' myext];
        V.descrip = 'GM segment, generated using old segment';
        dat = uint8(g);
        spm_write_vol(V,dat);

        V = VO(2);
        V.fname = [mypath filesep myname '_seg2' myext];
        V.descrip = 'WM segment, generated using old segment';
        dat = uint8(w);
        spm_write_vol(V,dat);

        V = VO(3);
        V.fname = [mypath filesep myname '_seg3' myext];
        V.descrip = 'CSF segment, generated using old segment';
        dat = uint8(c);
        spm_write_vol(V,dat);

  end;

  
return;
%=======================================================================

%=======================================================================
function [y1,y2,y3] = affine_transform(x1,x2,x3,M)
    y1 = M(1,1)*x1 + M(1,2)*x2 + M(1,3)*x3 + M(1,4);
    y2 = M(2,1)*x1 + M(2,2)*x2 + M(2,3)*x3 + M(2,4);
    y3 = M(3,1)*x1 + M(3,2)*x2 + M(3,3)*x3 + M(3,4);
return;
%=======================================================================

%=======================================================================
function M = get_affine_mapping(VF);

% generate affine matrix
  aff_flags_1    = struct('WG',[],'WF',[],'sep',4,'regtype','MNI');
  aff_flags_2    = struct('WG',[],'WF',[],'sep',2,'regtype','MNI');

% set template; assume T1 if large (yes, I know this is dirty)
  if any(VF.dim) > 128

	temp     = fullfile(spm('Dir'),'templates','T1.nii');

	try

		spm_vol(temp);
	catch

		temp     = fullfile(spm('Dir'),'toolbox','OldNorm', 'T1.nii');
	end;
  else

	temp     = fullfile(spm('Dir'),'templates','EPI.nii');
	try

		spm_vol(temp);
	catch

		temp     = fullfile(spm('Dir'),'toolbox','OldNorm', 'EPI.nii');
	end;

  end;

  [Affine, scal] = spm_affreg(spm_vol(temp), VF, aff_flags_1, eye(4));
  [Affine, scal] = spm_affreg(spm_vol(temp), VF, aff_flags_2, Affine, scal);

% replace
  M = Affine;

return;
%=======================================================================

%=======================================================================
function [x1,x2,x3] = get_sampling(MM,VF,samp,bb1)
% Voxels to sample during the cluster analysis
%-----------------------------------------------------------------------

% A bounding box for the brain in Talairach space.
if nargin<4, bb1 = [ [-88 88]' [-122 86]' [-60 95]']; end;

% A mapping from a unit radius sphere to a hyper-ellipse
% that is just enclosed by the bounding box in Talairach
% space.
M0 = [diag(diff(bb1)/2) mean(bb1)';[0 0 0 1]];

% The mapping from voxels to Talairach space is MM,
% so the ellipse in the space of the image becomes:
M0 = MM\M0;

% So to work out the bounding box in the space of the
% image that just encloses the hyper-ellipse.
tmp = M0(1:3,1:3);
tmp = diag(tmp*tmp'/diag(sqrt(diag(tmp*tmp'))));
bb  = round([M0(1:3,4)-tmp M0(1:3,4)+tmp])';
bb  = min(max(bb,[1 1 1 ; 1 1 1]),[VF(1).dim(1:3) ; VF(1).dim(1:3)]);

% Want to sample about every 3mm
tmp  = sqrt(sum(VF(1).mat(1:3,1:3).^2))';
samp = round(max(abs(tmp.^(-1)*samp), [1 1 1]'));

x1 = bb(1,1):samp(1):bb(2,1);
x2 = bb(1,2):samp(2):bb(2,2);
x3 = bb(1,3):samp(3):bb(2,3);

return;
%=======================================================================

%=======================================================================
function [CP,BP,SP] = run_segment(CP,BP,SP,VF,sums,x1,x2,x3)
oll = -Inf;
% spm_chi2_plot('Init','Segmenting','Log-likelihood','Iteration #');

for iter = 1:64,
    ll= 0;
    for pp = 1:length(x3), % Loop over planes
        bf        = get_bp(BP,x1,x2,x3(pp));
        [raw,msk] = get_raw(VF,x1,x2,x3(pp));
        s         = get_sp(SP,x1,x2,x3(pp));
        cor       = bf.*raw;
        [P,ll0]   = get_p(cor,msk,s,sums,CP,bf);
        ll        = ll + ll0;
        CP        = update_cp_est(CP,P,cor,msk,pp);
        BP        = update_bp_est(BP,P,cor,CP,msk,x1,x2,x3(pp));
    end;

    BP = update_bp(BP);
    % if iter>1, spm_chi2_plot('Set',ll); end;
    %fprintf('\t%g\n', ll);

    % Stopping criterion
    %-----------------------------------------------------------------------
    if iter == 2,
        ll2 = ll;
    elseif iter > 2 && abs((ll-oll)/(ll-ll2)) < 0.0001
        break;
    end;
    oll = ll;
end;
% spm_chi2_plot('Clear');
return;
%=======================================================================

%=======================================================================
function BP = init_bp(VF,co,reg)
m        = length(VF);
tmp      = sqrt(sum(VF(1).mat(1:3,1:3).^2));
BP.nbas  = max(round((VF(1).dim(1:3).*tmp)/co),[1 1 1]);
BP.B1    = spm_dctmtx(VF(1).dim(1),BP.nbas(1));
BP.B2    = spm_dctmtx(VF(1).dim(2),BP.nbas(2));
BP.B3    = spm_dctmtx(VF(1).dim(3),BP.nbas(3));

nbas     = BP.nbas;
if prod(BP.nbas)>1,
    % Set up a priori covariance matrix
    vx = sqrt(sum(VF(1).mat(1:3,1:3).^2));
    kx=(pi*((1:nbas(1))'-1)*pi/vx(1)/VF(1).dim(1)*10).^2;
    ky=(pi*((1:nbas(2))'-1)*pi/vx(2)/VF(1).dim(2)*10).^2;
    kz=(pi*((1:nbas(3))'-1)*pi/vx(3)/VF(1).dim(3)*10).^2;

    % Cost function based on sum of squares of 4th derivatives
    IC0 =  (1*kron(kz.^4,kron(ky.^0,kx.^0)) +...
            1*kron(kz.^0,kron(ky.^4,kx.^0)) +...
            1*kron(kz.^0,kron(ky.^0,kx.^4)) +...
            4*kron(kz.^3,kron(ky.^1,kx.^0)) +...
            4*kron(kz.^3,kron(ky.^0,kx.^1)) +...
            4*kron(kz.^1,kron(ky.^3,kx.^0)) +...
            4*kron(kz.^0,kron(ky.^3,kx.^1)) +...
            4*kron(kz.^1,kron(ky.^0,kx.^3)) +...
            4*kron(kz.^0,kron(ky.^1,kx.^3)) +...
            6*kron(kz.^2,kron(ky.^2,kx.^0)) +...
            6*kron(kz.^2,kron(ky.^0,kx.^2)) +...
            6*kron(kz.^0,kron(ky.^2,kx.^2)) +...
           12*kron(kz.^2,kron(ky.^1,kx.^1)) +...
           12*kron(kz.^1,kron(ky.^2,kx.^1)) +...
           12*kron(kz.^1,kron(ky.^1,kx.^2)) )*reg;

    %IC0(1) = max(IC0);
    BP.IC0 = diag(IC0(2:end));

    % Initial estimate for intensity modulation field
    BP.T   = zeros(nbas(1),nbas(2),nbas(3),length(VF));
    %-----------------------------------------------------------------------
else
    BP.T   = zeros([1 1 1 length(VF)]);
    BP.IC0 = [];
end;
BP.Alpha = zeros(prod(BP.nbas(1:3)),prod(BP.nbas(1:3)),m);
BP.Beta  = zeros(prod(BP.nbas(1:3)),m);
return;
%=======================================================================

%=======================================================================
function BP = update_bp_est(BP,p,cor,CP,msk,x1,x2,x3)
if prod(BP.nbas)<=1, return; end;
B1 = BP.B1(x1,:);
B2 = BP.B2(x2,:);
B3 = BP.B3(x3,:);
for j=1:size(BP.Alpha,3),
    cr  = cor(:,:,j);
    w1 = zeros(size(cr));
    w2 = zeros(size(cr));
    for i=[1 2 3 4 5 6 7 8],
        tmp = p(:,:,i)*CP.cv(j,j,i)^(-1);
        w1  = w1 + tmp.*(CP.mn(j,i) - cr);
        w2  = w2 + tmp;
    end;
    wt1       = 1 + cr.*w1;
    wt2       = cr.*(cr.*w2 - w1);
    wt1(~msk) = 0;
    wt2(~msk) = 0;

    BP.Beta(:,j)    = BP.Beta(:,j)    + kron(B3',spm_krutil(wt1,B1,B2,0));
    BP.Alpha(:,:,j) = BP.Alpha(:,:,j) + kron(B3'*B3,spm_krutil(wt2,B1,B2,1));
end;
return;
%=======================================================================
 
%=======================================================================
function BP = update_bp(BP)
if prod(BP.nbas)<=1, return; end;
for j=1:size(BP.Alpha,3),
    x     = BP.T(:,:,:,j);
    x     = x(:);
    x     = x(2:end);
    Alpha = BP.Alpha(2:end,2:end,j);
    Beta  = BP.Beta(2:end,j);
    x     = (Alpha + BP.IC0)\(Alpha*x + Beta);

    BP.T(:,:,:,j) = reshape([0 ; x],BP.nbas(1:3));
    BP.Alpha      = zeros(size(BP.Alpha));
    BP.Beta       = zeros(size(BP.Beta));
end;
return;
%=======================================================================
 
%=======================================================================
function bf = get_bp(BP,x1,x2,x3)
bf = ones(length(x1),length(x2),size(BP.Alpha,3));
if prod(BP.nbas)<=1, return; end;
B1 = BP.B1(x1,:);
B2 = BP.B2(x2,:);
B3 = BP.B3(x3,:);
for i=1:size(BP.Alpha,3),
    t = reshape(reshape(BP.T(:,:,:,i),...
        BP.nbas(1)*BP.nbas(2),BP.nbas(3))*B3', BP.nbas(1), BP.nbas(2));
    bf(:,:,i) = exp(B1*t*B2');
end;
return;
%=======================================================================
 
%=======================================================================
function [dat,msk] = get_raw(VF,x1,x2,x3)
[X1,X2,X3] = ndgrid(x1,x2,x3);
for i=1:length(VF),
    [Y1,Y2,Y3] = affine_transform(X1,X2,X3,VF(i).mat\VF(1).mat);
    dat(:,:,i) = spm_sample_vol(VF(i),Y1,Y2,Y3,1);
end;
msk = all(dat,3) & all(isfinite(double(dat)),3);
return;
%=======================================================================
 
%=======================================================================
function CP = init_cp(VF,x3)
n = 8;
m = length(VF);
p = length(x3);
CP.mom0 = zeros(1,n,p)+eps;
CP.mom1 = zeros(m,n,p);
CP.mom2 = zeros(m,m,n,p)+eps;

% Occasionally the dynamic range of the images is such that many voxels
% all have the same intensity.  Adding cv0 is an attempt to improve the
% stability of the algorithm if this occurs. The value 0.083 was obtained
% from var(rand(1000000,1)).  It prbably isn't the best way of doing
% things, but it appears to work.
CP.cv0 = zeros(m,m);
for i=1:m,
    if spm_type(VF(i).dt(1),'intt'),
        CP.cv0(i,i)=0.083*mean(VF(i).pinfo(1,:));
    end;
end;
return;
%=======================================================================
 
%=======================================================================
function CP = shake_cp(CP)
CP.mom0(:,5,:)   = CP.mom0(:,1,:);
CP.mom0(:,6,:)   = CP.mom0(:,2,:);
CP.mom0(:,7,:)   = CP.mom0(:,3,:);
CP.mom1(:,5,:)   = CP.mom1(:,1,:);
CP.mom1(:,6,:)   = CP.mom1(:,2,:);
CP.mom1(:,7,:)   = CP.mom1(:,3,:);
CP.mom1(:,8,:)   = 0;
CP.mom2(:,:,5,:) = CP.mom2(:,:,1,:);
CP.mom2(:,:,6,:) = CP.mom2(:,:,2,:);
CP.mom2(:,:,7,:) = CP.mom2(:,:,3,:);
return;
%=======================================================================
 
%=======================================================================
function CP = update_cp_est(CP,P,dat,msk,p)
m   = size(dat,3);
d   = size(P);
P   = reshape(P,[d(1)*d(2),d(3)]);
dat = reshape(dat,[d(1)*d(2),m]);
P(~msk(:),:)   = [];
dat(~msk(:),:) = [];
for i=1:size(CP.mom0,2),
    CP.mom0(1,i,p)   = sum(P(:,i));
    CP.mom1(:,i,p)   = sum((P(:,i)*ones(1,m)).*dat)';
    CP.mom2(:,:,i,p) = ((P(:,i)*ones(1,m)).*dat)'*dat;
end;

for i=1:size(CP.mom0,2),
    CP.mg(1,i)   = sum(CP.mom0(1,i,:),3);
    CP.mn(:,i)   = sum(CP.mom1(:,i,:),3)/CP.mg(1,i);

    tmp          = (CP.mg(1,i).*CP.mn(:,i))*CP.mn(:,i)';
    tmp          = tmp-eye(size(tmp))*eps*1e6;
    CP.cv(:,:,i) = (sum(CP.mom2(:,:,i,:),4) - tmp)/CP.mg(1,i) + CP.cv0;
end;
CP.mg   = CP.mg/sum(CP.mg);
return;
%=======================================================================
 
%=======================================================================
function [p,ll] = get_p(cor,msk,s,sums,CP,bf)
d   = [size(cor) 1 1];
n   = size(CP.mg,2);
cor = reshape(cor,d(1)*d(2),d(3));
cor = cor(msk,:);
p   = zeros(d(1)*d(2),n);
if ~any(msk), p  = reshape(p,d(1),d(2),n); ll=0; return; end;

for i=1:n,
    amp       = 1/sqrt((2*pi)^d(3) * det(CP.cv(:,:,i)));
    dst       = (cor-ones(size(cor,1),1)*CP.mn(:,i)')/sqrtm(CP.cv(:,:,i));
    dst       = sum(dst.*dst,2);
    tmp       = s(:,:,i);
    p(msk,i)  = (amp*CP.mg(1,i)/sums(i))*exp(-0.5*dst).*tmp(msk) +eps;
end;
sp = sum(p,2);
ll = sum(log(sp(msk).*bf(msk)+eps));
sp(~msk) = Inf;
for i=1:n, p(:,i) = p(:,i)./sp; end;
p  = reshape(p,d(1),d(2),n);
return;
%=======================================================================
 
%=======================================================================
function SP = init_sp(flags,VF)
SP.VB       = spm_vol(flags.priors);
MM          = get_affine_mapping(VF);
%VF          = spm_vol(PF);
SP.MM       = MM*VF(1).mat;
SP.w        = 0.98;
return;
%=======================================================================
 
%=======================================================================
function s = get_sp(SP,x1,x2,x3)
[X1,X2,X3] = ndgrid(x1,x2,x3);
[Y1,Y2,Y3] = affine_transform(X1,X2,X3,SP.VB(1).mat\SP.MM);
w1  = SP.w;
w2  = (1-w1)/2;
s   = zeros([size(Y1),4]);
for i=1:3,
    s(:,:,i) = spm_sample_vol(SP.VB(i),Y1,Y2,Y3,1)*w1+w2;
end;
s(:,:,4:8)   = repmat(abs(1-sum(s(:,:,1:3),3))/5,[1 1 5]);
return;
%=======================================================================
 
%=======================================================================
function [g,w,c] = get_gwc(VF,BP,SP,CP,sums,wc)

if wc,
    VC = VF;
    for j=1:length(VF),
        [pth,nm,xt,vr] = spm_fileparts(deblank(VF(j).fname));
        VC(j).fname    = fullfile(pth,['m' nm xt vr]);
        VC(j).descrip  = 'Bias corrected image';
    end;
    VC = spm_create_vol(VC);
end;

% spm_progress_bar('Init',VF(1).dim(3),'Creating Segmented','planes completed');
x1 = 1:VF(1).dim(1);
x2 = 1:VF(1).dim(2);
x3 = 1:VF(1).dim(3);

g = uint8(0); g(VF(1).dim(1),VF(1).dim(2),VF(1).dim(3)) = 0;
w = uint8(0); w(VF(1).dim(1),VF(1).dim(2),VF(1).dim(3)) = 0;
c = uint8(0); c(VF(1).dim(1),VF(1).dim(2),VF(1).dim(3)) = 0;

for pp=1:length(x3),
    bf        = get_bp(BP,x1,x2,x3(pp));
    [raw,msk] = get_raw(VF,x1,x2,x3(pp));
    cor       = raw.*bf;
    if wc,
        for j=1:length(VC),
            VC(j) = spm_write_plane(VC(j),cor(:,:,j),pp);
        end;
    end;
    s         = get_sp(SP,x1,x2,x3(pp));
    p         = get_p(cor,msk,s,sums,CP,bf);
    g(:,:,pp) = uint8(round(p(:,:,1)*255));
    w(:,:,pp) = uint8(round(p(:,:,2)*255));
    c(:,:,pp) = uint8(round(p(:,:,3)*255));

    % spm_progress_bar('Set',pp);
end;
% spm_progress_bar('Clear');

return;
%=======================================================================
 
%=======================================================================
function [g,w,c,b] = clean_gwc(g,w,c)
%  b    = w;  % instead of setting brain to w, use w+c instead 
%  b(1) = w(1);
  b    = w + c;


% Build a 3x3x3 seperable smoothing kernel
%-----------------------------------------------------------------------
kx=[0.75 1 0.75];
ky=[0.75 1 0.75];
kz=[0.75 1 0.75];
sm=sum(kron(kron(kz,ky),kx))^(1/3);
kx=kx/sm; ky=ky/sm; kz=kz/sm;

% Erosions and conditional dilations
%-----------------------------------------------------------------------
niter = 32;
% spm_progress_bar('Init',niter,'Extracting Brain','Iterations completed');
for j=1:niter,
    if j>2, th=0.15; else th=0.6; end; % Dilate after two its of erosion.
    for i=1:size(b,3),
        gp = double(g(:,:,i));
        wp = double(w(:,:,i));
        bp = double(b(:,:,i))/255;
        bp = (bp>th).*(wp+gp);
        b(:,:,i) = uint8(round(bp));
    end;
    spm_conv_vol(b,b,kx,ky,kz,-[1 1 1]);
    % spm_progress_bar('Set',j);
end;


th = 0.05;
for i=1:size(b,3),
    gp       = double(g(:,:,i))/255;
    wp       = double(w(:,:,i))/255;
    cp       = double(c(:,:,i))/255;
    bp       = double(b(:,:,i))/255;
    bp       = ((bp>th).*(wp+gp))>th;
    g(:,:,i) = uint8(round(255*gp.*bp./(gp+wp+cp+eps)));
    w(:,:,i) = uint8(round(255*wp.*bp./(gp+wp+cp+eps)));
    c(:,:,i) = uint8(round(255*(cp.*bp./(gp+wp+cp+eps)+cp.*(1-bp))));
    b(:,:,i) = uint8(round(255*bp));
end;

% only use largest cluster
  [temp2,num] = spm_bwlabel(double(b > 0.5),18);
  store = zeros(num,1);
  for i = 1:num,  store(i) = sum(sum(sum(temp2==i)));  end;
  targ = find(store == max(store));
  b = double(temp2 == targ).*255;
  
  
% fill holes by inverting and filling small clusters
  fillin = 50;
  [temp2,num] = spm_bwlabel(double(b < 1),18);
  store = zeros(num,1);
  for i = 1:num,  store(i) = sum(sum(sum(temp2==i)));  end;
  if min(store < fillin)
          targ = zeros(size(temp2));
          for i = 1:num
                  if store(i) < fillin
                          targ(find(temp2 == store(i))) = 255;
                  end;
          end;
  end;
  b = (double(b + targ) > 1).*255;
    

% final smoothing
  spm_conv_vol(b,b,kx,ky,kz,-[1 1 1]);


% spm_progress_bar('Clear');
return;

% ==========================================================================================================
%                                          Embedded functions: #2, findn
% ==========================================================================================================
function ind=findn(arr);

%FINDN   Find indices of nonzero elements.
%   I = FINDN(X) returns the indices of the vector X that are
%   non-zero. For example, I = FINDN(A>100), returns the indices
%   of A where A is greater than 100. See RELOP.
%  
%   This is the same as find but works for N-D matrices using 
%   ind2sub function
%
%   It does not return the vectors as the third output arguement 
%   as in FIND
%   
%   The returned I has the indices (in actual dimensions)
%
%   x(:,:,1)            x(:,:,2)            x(:,:,3)
%       = [ 1 2 3           =[11 12 13        =[21 22 23
%           4 5 6             14 15 16          24 25 26
%           7 8 9]            17 18 19]         27 28 29]
%
%   I=find(x==25) will return 23
%   but findn(x==25) will return 2,2,3
%   
%   Also see find, ind2sub

%   Loren Shure, Mathworks Inc. improved speed on previous version of findn
%   by Suresh Joel Mar 3, 2003

in=find(arr);
sz=size(arr);
if isempty(in), ind=[]; return; end;
[out{1:ndims(arr)}] = ind2sub(sz,in);
ind = cell2mat(out);

% ==========================================================================================================
%                                          Embedded functions: #3, subdir
% ==========================================================================================================

function varargout = subdir(varargin)
%SUBDIR Performs a recursive file search
%
% subdir
% subdir(name)
% files = subdir(...)
%
% This function performs a recursive file search.  The input and output
% format is identical to the dir function.
%
% Input variables:
%
%   name:   pathname or filename for search, can be absolute or relative
%           and wildcards (*) are allowed.  If ommitted, the files in the
%           current working directory and its child folders are returned    
%
% Output variables:
%
%   files:  m x 1 structure with the following fields:
%           name:   full filename
%           date:   modification date timestamp
%           bytes:  number of bytes allocated to the file
%           isdir:  1 if name is a directory; 0 if no
%
% Example:
%
%   >> a = subdir(fullfile(matlabroot, 'toolbox', 'matlab', '*.mat'))
%
%   a = 
%
%   67x1 struct array with fields:
%       name
%       date
%       bytes
%       isdir
%
%   >> a(2)
%
%   ans = 
%
%        name: '/Applications/MATLAB73/toolbox/matlab/audiovideo/chirp.mat'
%        date: '14-Mar-2004 07:31:48'
%       bytes: 25276
%       isdir: 0
%
% See also:
%
%   dir
% Copyright (c) 2009, Kelly Kearney
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without 
% modification, are permitted provided that the following conditions are 
% met:
%
%    * Redistributions of source code must retain the above copyright 
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright 
%      notice, this list of conditions and the following disclaimer in 
%      the documentation and/or other materials provided with the distribution
%      
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
% POSSIBILITY OF SUCH DAMAGE.

%---------------------------
% Get folder and filter
%---------------------------

error(nargchk(0,1,nargin));
error(nargoutchk(0,1,nargout));

if nargin == 0
    folder = pwd;
    filter = '*';
else
    [folder, name, ext] = fileparts(varargin{1});
    if isempty(folder)
        folder = pwd;
    end
    if isempty(ext)
        if isdir(fullfile(folder, name))
            folder = fullfile(folder, name);
            filter = '*';
        end
    else
        filter = [name ext];
    end
end

%---------------------------
% Search all folders
%---------------------------

pathstr = genpath(folder);
seplocs = findstr(pathstr, pathsep);
loc1 = [1 seplocs(1:end-1)+1];
loc2 = seplocs(1:end)-1;
pathfolders = arrayfun(@(a,b) pathstr(a:b), loc1, loc2, 'UniformOutput', false);

Files = [];
for ifolder = 1:length(pathfolders)
    NewFiles = dir(fullfile(pathfolders{ifolder}, filter));
    if ~isempty(NewFiles)
        fullnames = cellfun(@(a) fullfile(pathfolders{ifolder}, a), {NewFiles.name}, 'UniformOutput', false); 
        [NewFiles.name] = deal(fullnames{:});
        Files = [Files; NewFiles];
    end
end

%---------------------------
% Output
%---------------------------
    
if nargout == 0
    if ~isempty(Files)
        fprintf('\n');
        fprintf('%s\n', Files.name);
        fprintf('\n');
    end
elseif nargout == 1
    varargout{1} = Files;
end
return;
